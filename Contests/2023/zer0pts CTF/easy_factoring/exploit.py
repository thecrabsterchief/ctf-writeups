from sage.all import *
from pwn import *
from Crypto.Util.number import *
from jvdsn.shared import *
from itertools import product

def mods(a, n):
    if n <= 0:
        return "negative modulus"
    a = a % n
    if (2 * a > n):
        a -= n
    return a

def powmods(a, r, n):
    out = 1
    while r > 0:
        if (r % 2) == 1:
            r -= 1
            out = mods(out * a, n)
        r //= 2
        a = mods(a * a, n)
    return out

def quos(a, n):
    if n <= 0:
        return "negative modulus"
    return (a - mods(a, n))//n

def grem(w, z):
    # remainder in Gaussian integers when dividing w by z
    (w0, w1) = w
    (z0, z1) = z
    n = z0 * z0 + z1 * z1
    if n == 0:
        return "division by zero"
    u0 = quos(w0 * z0 + w1 * z1, n)
    u1 = quos(w1 * z0 - w0 * z1, n)
    return(w0 - z0 * u0 + z1 * u1,
           w1 - z0 * u1 - z1 * u0)

def ggcd(w, z):
    while z != (0,0):
        w, z = z, grem(w, z)
    return w

def root4(p):
    Px = PolynomialRing(Zmod(p), "x"); x = Px.gen()
    fx = x**4 - 1
    return fx.roots()

def sq2(p):
    if p == 2:
        return [(1, 1)]
    A = root4(p)
    print(A)
    return [ggcd((p,0),(a,1)) for a in A]

def merge(a,b,x,y):
    return a*x+b*y,a*y-b*x

def sumOfSquares(n, vp):
 
    # Iterate a loop from 1 to Math.sqrt(n)
    for i in range(1, 1 + int(n ** 0.5)):
  
        # If i*i is square check if there
        # exists another integer such that
        # h is a perfect square and i*i + h = n
        h = n - i * i
        h1 = int(h ** 0.5)
      
        # If h is perfect square
        if (h1 * h1 == h):
                  
            # Store in the sorted way
            a = max(h1, i)
            b = min(h1, i);
             
            # If there is already a pair
            # check if pairs are equal or not
            if (len(vp) == 1 and a != vp[0][0]):
                vp.append([a, b]);
      
            # Insert the first pair
            if (len(vp) == 0):
                vp.append([a, b]);
      
            # If two pairs are found
            if (len(vp) == 2):
                return;

io = remote("crypto.2023.zer0pts.com", 10333)

io.recvuntil(b"N: ")
N = int(io.recvline())

fac = factor(N)
roots = []

for (pr, e) in fac:
    roots += [sq2(pr**e)]

print(roots)
for root in product(*roots):
    p, q = root[0]
    for r in root[1:]:
        p, q = merge(p, q, r[0], r[1])
    
    p, q = abs(p), abs(q)
    if p**2 + q**2 == N:
        print('heh')
    if isPrime(int(p)) and isPrime(int(q)) and p**2 + q**2 == N:
        print(p, q)
        io.sendlineafter(b"p: ", str(abs(p)).encode())
        io.sendlineafter(b"q: ", str(abs(q)).encode())
        io.interactive()